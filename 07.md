# 2023年京东笔试真题0819

## 133.夹吃棋

[题目链接](https://kamacoder.com/problempage.php?pid=1209)

这道题代码写的有点史山了，太多重复了。

题目还看错了，重点那个节点不需要斜着处理。

~~~
#include <bits/stdc++.h>
using namespace std;

bool func1(vector<vector<char>>& chessBox,char target)
{
    if(chessBox[0][0]==target&&chessBox[2][2]==target) return true;
    if(chessBox[1][0]==target&&chessBox[1][2]==target) return true;
    if(chessBox[2][0]==target&&chessBox[0][2]==target) return true;
    if(chessBox[0][1]==target&&chessBox[2][1]==target) return true;
    return false;
}

bool func2(vector<vector<char>>& chessBox,char target,int x)
{
    if(chessBox[x][0]==target&&chessBox[x][2]==target) return true;
    return false;
}

bool func3(vector<vector<char>>& chessBox,char target,int y)
{
    if(chessBox[0][y]==target&&chessBox[2][y]==target) return true;
    return false;
}

int main()
{
    int t;
    cin>>t;
    vector<vector<char>> chessBox(3,vector<char>(3));
    while(t--)
    {
        for(int i = 0;i<3;i++)
        {
            for(int j = 0;j<3;j++)
            {
                cin >> chessBox[i][j];
         }
        }
        bool red = false;
        bool purple = false;
        if(chessBox[1][1]!='.')
        {
            if(chessBox[1][1]=='o')
            {
                if(func1(chessBox,'*')) red = true;
            }
            if(chessBox[1][1]=='*')
            {
                if(func1(chessBox,'o')) purple = true;
            }
        }

        if(chessBox[1][0]!='.')
        {
            if(chessBox[1][0]=='o')
            {
                if(func3(chessBox,'*',0)) red = true;
            }
            if(chessBox[1][0]=='*')
            {
                if(func3(chessBox,'o',0)) purple = true;
            }
        }
        if(chessBox[1][2]!='.')
        {
            if(chessBox[1][2]=='o')
            {
                if(func3(chessBox,'*',2)) red = true;
            }
            if(chessBox[1][2]=='*')
            {
                if(func3(chessBox,'o',2)) purple = true;
            }
        }

        if(chessBox[0][1]!='.')
        {
            if(chessBox[0][1]=='o')
            {
                if(func2(chessBox,'*',0)) red = true;
            }
            if(chessBox[0][1]=='*')
            {
                if(func2(chessBox,'o',0)) purple = true;
            }
        }
        if(chessBox[2][1]!='.')
        {
            if(chessBox[2][1]=='o')
            {
                if(func2(chessBox,'*',2)) red = true;
            }
            if(chessBox[2][1]=='*')
            {
                if(func2(chessBox,'o',2)) purple = true;
            }
        }
        if(red&&!purple) cout<<"kou"<<endl;
        else if(!red&&purple) cout<<"yukan"<<endl;
        else cout<<"draw"<<endl;
   
    }
    return 0;
}
~~~

## 134.小红买药

[题目链接](https://kamacoder.com/problempage.php?pid=1210)

其实很简单的一道题，但遇见了一个很严重的问题。

就是在cin的过程中，我误将数组的char写成了int，这就导致比如“1001”明明是cin4次的，但我int一次就输入完了，这使得后面的cin没有进行。

这个问题还真得需要严肃注意。

~~~
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    vector<char> curSymptom(n);
    for(int i = 0;i<n;i++)
    {
        cin>>curSymptom[i];
    }

    int m;
    cin>>m;
    vector<vector<char>> cure(m,vector<char>(n));
    vector<vector<char>> hurt(m,vector<char>(n));
    for(int i = 0;i<m;i++)
    {
        for(int j = 0;j<n;j++)
        {
            cin>>cure[i][j];
        }
        for(int j = 0;j<n;j++)
        {
            cin>>hurt[i][j];
        }
    }
    int q;
    cin>>q;
    for(int i = 0;i<q;i++)
    {
        int target;
        cin>>target;
        int symptomNums = 0;
                  
        for(int j = 0;j<n;j++)
        {
            if(cure[target-1][j]=='1' && curSymptom[j]=='1')
            {
                curSymptom[j] = '0';
            }
            if(hurt[target-1][j]=='1'  && curSymptom[j]=='0')
            {
                curSymptom[j] = '1';
            }
            if(curSymptom[j]=='1') symptomNums++; 
        }               
        cout<<symptomNums<<endl;
    }
    return 0;
}
~~~


## 135.皇后移动的最小步数

[题目链接](https://kamacoder.com/problempage.php?pid=1211)

真是想不到怎么做，终于在评论区找到一个能看懂的答案了，真不容易···

动规的思路，不过我自己真是没想到，可以把它理解成为一种贪心。

因为对于到达任意一个位置的最小步数，肯定是基于这个位置的上方的位置，左面的位置，左上方的位置，那么就一点点去推过去。

dp[i][j] 表示在到达（i,j）的位置所需要的最小步数。

然后初始化最上一行和最左列以及斜着的那一行。（斜着的那一行可初始化，也可不初始化）

还有要个 vector<vector<string>> dir(n,vector<string>(m,"000")); dir 记录走到当前这个节点所用最小步数的时候，所面朝的方向。

对于动规主题，那么就要考虑三个点所面朝的方向，考虑是否要改变走向的方向（是否加1），然后取最小值，判断取得是哪个值，从而改变当前节点的方面（即修改当前节点的dir）。

还有就是注意一下 一些特判情况。

这么一分析，感觉也不是很难（确实···）。

~~~
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,m;
    cin>>n>>m;
    //特判，终点即起点
    if(n==1 && m==1)
    {
        cout<<"0";
        return 0;
    }

    vector<string> pos(n);
    for(int i = 0;i<n;i++)
    {
        cin>>pos[i];
    }

    //特判，起点出现障碍物
    if(pos[0][0] == '*')
    {
        cout<<"-1";
        return 0;
    }

    vector<vector<int>> dp(n,vector<int>(m,INT_MAX - 1));
    //dir代表这个节点可以继续走的方向 按顺序分别是  下 右下 右
    vector<vector<string>> dir(n,vector<string>(m,"000"));
    dp[0][0] = 1;
    dir[0][0] = "111";

    //相当于初始化，把最上一行和最左列都处理了，因为后续动规需要用到 左 上 左上。
    for(int i = 1;i<n && pos[i][0]!='*';i++)
    {
        dp[i][0] = 1;
        dir[i][0] = "100";
    }
     for(int j=1;j<m && pos[0][j]!='*';j++){
        dp[0][j] = 1;
        dir[0][j] = "001";
    }
    

    for(int i = 1;i<n;i++)
    {
        for(int j  =1;j<m;j++)
        {
            if(pos[i][j]=='*') continue;
            int dir1,dir2,dir3;
            //考虑当前格子的 左边 左上  上边 的格子
            //如果左边的格子 的方向 如果是右 则直接继承
            //不是右 则要在左边的格子的步数基础上+1得当前格子的步数
            //其余格子 规律相同
            if(dir[i][j-1][2]=='1') dir1 = dp[i][j-1];
            else dir1 = dp[i][j-1] + 1;
            if(dir[i-1][j-1][1]=='1') dir2 = dp[i-1][j-1];
            else dir2 = dp[i-1][j-1] + 1;
            if(dir[i-1][j][0]=='1') dir3 = dp[i-1][j];
            else dir3 = dp[i-1][j] + 1;

            dp[i][j] = min(dir1,min(dir2,dir3));
            if(dp[i][j]==dir1) dir[i][j][2] = '1';
            if(dp[i][j] == dir2) dir[i][j][1] = '1';
            if(dp[i][j] == dir3) dir[i][j][0] = '1';
            
        }
    }

    if(dp[n-1][m-1]==INT_MAX || dp[n-1][m-1]==INT_MAX-1) cout<<"-1";
    else cout<<dp[n-1][m-1];
    return 0;
}
~~~