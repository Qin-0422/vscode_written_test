# 2023年小红书提前批笔试真题0723

## 124.小红的数组构造

[题目链接](https://kamacoder.com/problempage.php?pid=1200)

这道题就很简单了，最小数组就是 1k，2k，3k···

不过这道题藏了一个阴的点，就是要注意到n和k的取值范围，用int会超时，改成long long

幸好我十分敏锐（hhh），提前把int改成unsigned long long了。

这里我们再重新熟悉一下各个类型的范围。

int ：通常是 32 位，范围约 -2^31 ~ 2^31-1 （ -2147483648 ~ 2147483647 ） （21亿多，10位数字）

long long ：固定至少 64 位，范围约 -2^63 ~ 2^63-1 （ -9223372036854775808 ~ 9223372036854775807 ）(19位数字)

size_t ：无符号，用于数组长度与索引（在 64 位平台一般是 64 位）。

识别何时需要更大类型

- 输入约束出现 10^9 以上：和/乘法通常至少用 long long 。
  
- 需要计算乘法链或阶乘级别：很快超过 64 位，考虑 __int128 或大数库/字符串。
  
- 图/树问题里路径数、方案数可能非常大：若不取模，考虑更大类型或改算法。
  
- 计数类问题用 size_t 存储大小，但参与算术时转回有符号整型以避免负数与无符号混算。


~~~
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n,k;
    cin>>n>>k;
    unsigned long long  result = 0;
    for(int i = 1;i<=n;i++)
    {
        result += i*k;
    }
    cout<<result<<endl;
    return 0;
}
~~~

## 125.精华帖子

[题目链接](https://kamacoder.com/problempage.php?pid=1201)

题不是很难，但刚开始我却没读懂题目的意思。

滑动窗口，窗口大小为k，进来一个1，就加1；出去一个1，就减1。

这个题解是我看的评论区，里面有很巧妙的记录数组为0还是1的写法。

~~~
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
int n,k,m;
void solve()
{
   cin >> n >> m >> k;
   vector<int> arr(n+1,0);
   for(int i=0;i<m;++i)
   {
        int l,r;
        cin >> l >> r;
        arr[l]++,arr[r]--;
   }
   for(int i=1;i<n;++i) 
   arr[i] += arr[i-1];
   int left = 0,right = k-1;
   int cnt[2] = {0};
   for(int i=0;i<k;++i)
   {
     cnt[arr[i]]++; 
   }
   int ans = cnt[1];
   while(right<n-1){
        ++left,++right;
        cnt[arr[left-1]]--,cnt[arr[right]]++;
        ans = max(ans,cnt[1]);  
   }
   cout << ans <<endl;
}
int main()
{
    cin.tie(0)->sync_with_stdio(false);
    solve();
    return 0;
}
~~~

为什么我没自己写题解呢，我写了，超时了······

似乎因为卡码网的测试数据较弱，n的数据很大，如果按照内存512M，极限情况下无法创建这么大的数组，那上面的做法也就不行了。

然后我就找到了一种时间换空间的做法：

在定义二维数组的时候，就只定义 m行2列。

俩重循环统计不同精华区间的总数量。


虽然还是超时了，但我觉得也是一个很不错的思路。
~~~
#include <bits/stdc++.h>
using namespace std;

bool cmp(const vector<int>&a,const vector<int>&b)
{
    return a[0]<b[0];
}

int main()
{
    int n,m,k;
    cin>>n>>m>>k;
    
    vector<vector<int>> range(m,vector<int>(2,0));
    for(int i = 0;i<m;i++)
    {
        cin>>range[i][0]>>range[i][1];
    }

    sort(range.begin(),range.end(),cmp);

    int result = 0;
    int sum = 0;
    for(int i = 0;i<m;i++)
    {
        int j = i;
        while(j<m&&range[j][0]-range[i][0]<=k)
        {
            if(range[j][1]-range[i][0]<=k) sum += range[j][1]-range[j][0];
            else sum += k - (range[j][0]-range[i][0]);
            j++;
        }
        result = max(result,sum);
        sum = 0;
    }

    cout<<result<<endl;
    return 0;
}
~~~

## 126.连续子数组最大和

[题目链接](https://kamacoder.com/problempage.php?pid=1202)

想试着用动规做做。

dp[i][0]: 表示到第i位元素，且没有修改过元素的连续子数组最大和

dp[i][1]: 表示到第i位元素，且修改过元素的连续子数组最大和

那么dp[i][0] = max(dp[i-1][0] +nums[i],nums[i]);

    used = max(dp[i-1][1]+nums[i],nums[i]);

    unused = max(dp[i-1][0]+x,x);

    dp[i][1] = max(used,unused);

    每次的时候都记录一下max，这样得到的就是连续的result，而dp[nums.size()-1][0or1]可不是最终结果。

那这样这道题基本就解决了~


（ps: 想到使用动规了，但递推公式没想明白，看了评论区。就卡在连续这个问题上，真没想到可以用一个result一步一记录）

~~~
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main()
{
    int t;
    cin>>t;
    int n;
    ll x;
    while (t--)
    {
        cin>>n>>x;
        vector<ll> nums(n);
        for(int i = 0;i<n;i++)
        {
            cin>>nums[i];
        }

        vector<vector<ll>> dp(n,vector<ll>(2,0));
        dp[0][0] = nums[0];
        dp[0][1] = x;

        ll result = max(dp[0][0],dp[0][1]);
        for(int i = 1;i<n;i++)
        {
            dp[i][0] = max(dp[i-1][0] + nums[i],nums[i]);
            ll used = max(dp[i-1][1]+nums[i],nums[i]);
            ll unused = max(dp[i-1][0]+x,x);
            dp[i][1] = max(used,unused);

            result = max(result,max(dp[i][0],dp[i][1]));
        }

        cout<<result<<endl;
    }
    
}
~~~