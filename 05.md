# 2023年用友提前批笔试真题0723

## 122.大数减法

[题目链接](https://kamacoder.com/problempage.php?pid=1198)

记得还是大一刚开学做的大数加法，知道自己肯定捋不清思路，这里ai出来，自己照着逻辑写。

思路：

  预处理：去除前导零；若两数相等直接返回 0
  
  比较大小：决定结果符号；若 a < b ，用 b-a 的绝对差并在前面加 -。
  
  逐位相减：从低位到高位相减，必要时向高位借 1（即加 10 再减）
  
  去前导零：相减后去除前导零，若全为零，返回 0

说一下遇到的问题：

1.错位相减的时候，要先反转，这样从小位数计算到大位数，遇 “0” 要借位。

2.反转是reverse(s.begin(),s.end()) ！！！ s.reserve() 是容器预留空间函数！！！

PS：分函数写看着就是顺眼！

~~~
#include <bits/stdc++.h>
using namespace std;

void preProcess(string& s)
{
    for(int i = 0;i<s.length();i++)
    {
        if(s[i]!='0')
        {
            s = s.substr(i,s.length()-i);
            break;
        }
    }
    if(s.length()==0) s ="0";
   
}
bool isEqual(string& s1,string& s2)
{
    if(s1.length()==s2.length())
    {
        for(int i = 0;i<s1.length();i++)
        {
            if(s1[i]!=s2[i])return false;
        }
        return true;
    }
    return false;
}

int compare(string& s1,string& s2)
{
    if(s1.length()>s2.length()) return 1;
    else if(s1.length()<s2.length()) return -1;
    else{
        for(int i = 0;i<s1.length();i++)
        {
            if(s1[i]>s2[i])return 1;
            else if(s1[i]<s2[i]) return -1;
            else continue;
        }
    }
    return 0;
}

void sub(string& s1,string& s2)
{
    reverse(s1.begin(), s1.end());
    reverse(s2.begin(), s2.end());
    for(int i = 0;i<s2.length();i++)
    {
        if(s1[i]>=s2[i]) s1[i] = s1[i] - (s2[i] - '0');
        else{
            for(int j = i+1;j<s1.length();j++)
            {
                if(s1[j]=='0') s1[j] = '9';
                else{
                    s1[j]--;
                    break;
                }
            }
            s1[i] -= (s2[i]-'0') - 10;
        }
    }
    reverse(s1.begin(), s1.end());
}

void my_swap(string& s1,string& s2)
{
    string temp = s1;
    s1 = s2;
    s2 = temp;
}

int main()
{
    //输入
    string s1;
    string s2;
    cin>>s1>>s2;

    //预处理
    preProcess(s1);
    preProcess(s2);
    if(isEqual(s1,s2))
    {
        cout<<"0";
        return 0;
    }

    //比较大小
    int com = compare(s1,s2);

    //错位相减
    if(com==-1)my_swap(s1,s2);
    sub(s1,s2);

    //去前导零
    preProcess(s1);

    //输出
    if(com==-1) cout<<"-";
    cout<<s1;
    return 0;
}
~~~

## 123.滑动窗口最大值

[题目链接](https://kamacoder.com/problempage.php?pid=1199)

我觉得可以定义俩个队列。

我不太清楚怎么说这个队列的设置，但以后肯定做过类似题，看具体实现吧。

终于有一道题有自己想法了，看看能不能自己实现。

我c了，才看见这输入什么史？？？

做完啦！先说输出，输出直接抄的，因为我知道自己写的话，逻辑肯定乱的一批。

> 注意字符串的cin，如果直接cin>>s，遇见" "就会停止。
> 但如果是getline(cin,s)，那就会遇到换行符才会停止。

分别记录 '[' , ']' , 'k'的位置。

使用好strsub，去切割; 用stoi 将字符串转成int。

注意在得到nums的时候，最后一个数字需要在循环外得到。

我们需要使用deque这种双向队列来实现单调队列，注意判断nums[i]和deque.back()的时候，用while而不是if。

别的就没有什么注意的了，我看了评论区，找到了类似题是 力扣原题 239. 滑动窗口最大值。

~~~
#include <bits/stdc++.h>
using namespace std;

void init(deque<int>& max,deque<int>& min, vector<int>& nums,int k)
{
    max.push_back (nums[0]);
    min.push_back(nums[0]);
    for(int i = 1;i<k;i++)
    {
        while(!max.empty()&&nums[i]>max.back())
        {
            max.pop_back();
        }
        max.push_back(nums[i]);

        while(!min.empty()&&nums[i]<min.back())
        {
            min.pop_back();
        }
        min.push_back(nums[i]);
    }
}

int main()
{
    //解决输入问题
    string s;
    getline(cin,s);
    int pos1,pos2;
    for(int i = 0;i<s.size();i++)
    {
        if(s[i]=='[') pos1 = i;
        else if(s[i]==']') pos2 = i;
    }
    int kpos = s.find('k')+4;
    int k = stoi(s.substr(kpos));
    string s1 = s.substr(pos1+1,pos2-pos1-1);
    int pos3 = -1;
    int pos4;
    vector<int> nums;
    for(int i = 0;i<s1.size();i++)
    {
        if(s1[i]==',')
        {
            pos4 = i;
            nums.push_back(stoi(s1.substr(pos3+1,pos4-pos3-1)));
            pos3 = pos4;
        }
    } 
    pos4 = s1.size();
    nums.push_back(stoi(s1.substr(pos3+1,pos4-pos3-1)));
    
    deque<int> mmax;
    deque<int> mmin;
    init(mmax,mmin,nums,k);
    int result = mmax.front()-mmin.front();
    
    int leftIndex = 0;
    int rightIndex = k;

    while(rightIndex<nums.size())
    {
        result = max(result,mmax.front()-mmin.front());

        if(nums[leftIndex]==mmax.front()) mmax.pop_front();
        if(nums[leftIndex]==mmin.front()) mmin.pop_front();

        while(!mmax.empty()&&nums[rightIndex]>mmax.back())
        {
            mmax.pop_back();
        }
        mmax.push_back(nums[rightIndex]);

        while(!mmin.empty()&&nums[rightIndex]<mmin.back())
        {
            mmin.pop_back();
        }
        mmin.push_back(nums[rightIndex]);


        leftIndex++;
        rightIndex++;
    }

    cout<<result<<endl;
    return 0;
}
~~~

