# 2023年科大讯飞提前批笔试真题0715

## 118.构造二阶行列式

[题目链接](https://kamacoder.com/problempage.php?pid=1192)

三个题的简单题，不多说了，不是0的位置，就让result++即可。

~~~
#include <iostream>
#include <vector>

using namespace std;

int getNotZero(int num)
{
    int result = 0;
    while (num>0)
    {
        if(num%10!=0)result++;
        num/=10;
    }
    return result;
}

int main()
{
    int  n;
    cin>>n;
    vector<int> arr(n);
    for(int i = 0;i<n;i++)
    {
        cin>>arr[i];
    }
    int result = 0;
    for(int i = 0;i<n;i++)
    {
        result += getNotZero(arr[i]);
    }
    cout<<result<<endl;
    return 0;
}
~~~


## 119.小红的字符串切割

[题目链接](https://kamacoder.com/problempage.php?pid=1193)

这道题的难度稍微上升了一点，主要考察解题逻辑，想明白其中思路就很好写了。

核心就是： 快慢指针 + 分类讨论

case 1：如果切割出来的相同字符数量小于三，直接输出-1，返回。

case 2：在不小于3的情况下，如果是个偶数，且不大于6，则不能分割成两个均为3以上的奇数，直接输出-1，返回。

case 3：如果大于等于3，是个奇数，存放。

case 4：就剩下数量为偶数，且大于6的情况了，我们把它拆分成3个和n-3个（也是奇数），分别存放。

这里我要说一下这个存放的问题。

由于我不熟悉map的机制，导致我琢磨了好久。

众所周知，unordered_map是无序的，那么我肯定是要用map的，但是由于如果我遇见大偶数，会有拆分的操作，那么我的容器里，要实现不同的key可以存放相同的元素，而map无法实现这一点。

于是我发现了multimap，它可是实现上面那个条件，但是又遇到问题了，multiple虽然是有序的，但是它的底层是基于红黑树实现的，它会根据key的大小默认自动升序排序，导致我输出顺序与答案不同。

最终没招了，使用了vector<pair<key,length>>这种存储方法（感觉不如用map帅）。

~~~
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    int n ;
    cin>>n;
    vector<char> arr(n);
    for(int i = 0;i<n;i++)
    {
        cin>>arr[i];
    }

    vector<pair<char,int>> mmap;

    int slowIndex = 0;
    int fastIndex = 1;
    for(;fastIndex<n;fastIndex++)
    {
        if(arr[fastIndex]==arr[slowIndex])
        {
            continue;
        }
        else
        {
            int len = fastIndex-slowIndex;
            if(len<3||(len%2==0&&len<6))
            {
                cout<<"-1"<<endl;
                return 0;
            }
            else if(len%2==1)
            {
                
                mmap.push_back({arr[slowIndex],len});
                slowIndex = fastIndex;
            }
            else 
            {
                mmap.push_back({arr[slowIndex],3});
                mmap.push_back({arr[slowIndex],len-3});
                slowIndex = fastIndex;
            }
        }
    }

    int len = fastIndex-slowIndex;
    if(len<3||(len%2==0&&len<6))
    {
        cout<<"-1"<<endl;
        return 0;
    }
    else if(len%2==1)
    {
        
        mmap.push_back({arr[slowIndex],len});
        slowIndex = fastIndex;
    }
    else 
    {
        mmap.push_back({arr[slowIndex],3});
        mmap.push_back({arr[slowIndex],len-3});
        slowIndex = fastIndex;
    }




    for(auto& pair : mmap)
    {
        for(auto j = 0;j<pair.second;j++)
        {
            cout<<pair.first;
        }
        cout<<" ";
    }
    return 0;
}
~~~


## 120.小红的数字匹配

[题目链接](https://kamacoder.com/problempage.php?pid=1194)

就没做过这么恶心的题。

先说一下我的思路，毫无疑问，我又在没有好思路的时候选择的递归，结果也是毫无疑问的超时。

（ps:以后做这种算法题，再也不用递归了，根本就通过不了······）

~~~
#include <bits/stdc++.h>
using namespace std;

int temp;
int result;
bool isGetResult;
int k;

void func(string& s,int qNum,int& len,int i)
{
    if(k==0) 
    {
        result = temp;
        if(i<len)
        {
            for(int j=i;j<len;j++)
            {
                result = result*10 + (s[j]-'0');
            }
        }
        isGetResult = true;
        return;
    }
    if(isGetResult)return;
    if(i>=len)return;

    if(s[i]=='?')
    {
        if(i!=0)
        {
            for(int j = 0;j<=9;j++)
            {
                temp = temp*10 + j;
                if(qNum==1)k--;
                func(s,qNum-1,len,i+1);
                temp = (temp-j)/10;
            }
        }
        else
        {
            for(int j = 1;j<=9;j++)
            {
                temp = temp*10 + j;
                if(qNum==1)k--;
                func(s,qNum-1,len,i+1);
                temp = (temp-j)/10;
            }
        }
    }
    else 
    {
        temp = temp*10 + (s[i]-'0');
        func(s,qNum,len,i+1);
        temp = (temp -(s[i]-'0'))/10;
    }
}

int main()
{
    int t;
    cin>>t;
    string s;
    for(int i = 0;i<t;i++)
    {
        cin>>s;
        cin>>k;
        int len = s.length();
        temp = 0;
        result= 0;
        int qNum = 0;
        isGetResult = false;
        
        for(int j = 0;j<len;j++)
        {
            if(s[j]=='?')
            qNum++;
        }

        bool isFirstQ = false;
        if(s[0]=='?') isFirstQ = true;

        int allK = 0;
        if(isFirstQ) allK = 9 * pow(10, qNum-1);
        else allK = pow(10, qNum);
        if(allK<k||s[0]=='0') 
        {
            cout<<"-1"<<endl;
            continue;
        }
        func(s,qNum,len,0);
        cout<<result<<endl;;
    }

    return 0;
}
~~~

然后看了一眼评论区，我根本没想到的思路：

这里我复制一下评论区的解释 

> 这个问题的核心在于意识到 求第k小即是在模板的最小数基础上在每个问号位置按顺序加上to_string后的k即可；
> 如??11??的最小值是101100，求其第4554大即在四个问号位置分别加上‘4’，‘5’，‘5’，‘4’即可，即551154；

然后自己尝试写了代码，但是有很大问题，解决不了，最终抄了源代码。

自己的理解思路用注释写在代码里了。

唉，第一次在笔试题里，看了思路还做不出来。

~~~
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n; //询问次数
    string s; //模式串
    string K; //这个后续 k值-1 后转化成string类型的存储
    vector<int> position;//记录‘？’的位置。
    int k;//第k小
    unsigned long  numofresult;//累计“总匹配个数”的乘积。遇到首位 ? 乘以 9 ，其他每个 ? 乘以 10 ，用来判断是否至少有 k 个匹配。也就是计算成不成立
    cin>>n;
    for(int i=0;i<n;i++)
    {
        s.clear();
        position.clear();
        k=0;
        numofresult=1;
        cin>>s;
        cin>>k;
        if(s[0]=='0')
        {
            cout<<-1<<endl;
            continue;
        }

        //-------------这之前都很好理解，一些初始化 清空处理。

        //计算numofresult 将所有的'?'换成0或1 并存储'?'位置，判断是否输出-1。
        for(int j=0;j<s.size();j++)
        {
            if(s[j]=='?')
            {
                if(j==0)
                {
                    s[j]='1';
                    numofresult*=9;
                }
                else
                {
                    s[j]='0';
                    numofresult*=10;
                }
                position.push_back(j);
            }
        }
        if(k>numofresult)
        {
            cout<<-1<<endl;
            continue;
        }

        //好好想想 k-1是必要的。
        k--;
        //index记录每个‘？’在s中的索引位置
        int index = position.size()-1;
        K=to_string(k);
        for(int j=K.size()-1;j>=0;j--)
        {
            s[position[index]]+=(K[j]-'0');
            index--;
        }
        cout<<s<<endl;
    }
    return 0;
}
~~~

还是那句话，学思路，找问题，加油！