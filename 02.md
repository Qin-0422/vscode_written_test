# 2023年OPPO提前批B组笔试真题0715

## 114.小欧的平均数

[题目链接](https://kamacoder.com/problempage.php?pid=1187)

说实话，这题出的真一般，题目根本没有明确三数平衡的定义，我以为是让三个数大小相等，结果却是使三个数全是奇或全是偶。

那没招了兄弟。

这里给出三数相等的题解（应该没错···）。

~~~
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool isOdd(int a)
{
    if(a%2==1)return true;
    return false;
}

//从小到大排序
void my_sort(int& x,int& y,int& z)
{
    if(y > z) swap(y,z);
    if(x > z) swap(x,y);
    if(y > z) swap(y,z);
}

int main()
{
    int x,y,z;
    cin>>x>>y>>z;

    my_sort(x,y,z);

    int result = 0;

    //记录初始三个数的奇偶情况
    int odd = 0;
    if(isOdd(x)) odd++;
    if(isOdd(y)) odd++;
    if(isOdd(z)) odd++;
    //第一种情况：三个数都是偶数
    if(odd==0)
    {
        result  = z-x;
    }
    //第二种：一奇俩偶
    else if(odd==1)
    {
       if(isOdd(y))
       {
            result = z-x+1;
       }
       else 
       {
            result  = z-x;
       }
    }
    //第三种：俩奇一偶
    else if(odd==2)
    {
       if(!isOdd(y))
       {
            result = z-x+1;
       }
       else 
       {
            result  = z-x;
       }
    }
    //最后一种：三奇
    else {
        result = z-x;
    }
    cout<<result;
    return 0;
}
~~~

然后给出原题题解吧，真没意思，直接cv的评论区 

~~~
#include<iostream>
#include<algorithm>
using namespace std;
int main() {
    int x, y, z;
    cin >> x >> y >> z;
    int cnt = (x % 2 == 0) + (y % 2 == 0) + (z % 2 == 0);
    cout << min(3 - cnt, cnt);
    return 0;
}
~~~


## 115.组装手机

[题目链接](https://kamacoder.com/problempage.php?pid=1188)

这道题没有思路，想着四重循环暴力解，但是没有实现。

不过也给我提了个醒，以后再遇到这道匹配问题的时候，一定要想到哈希表。

首先我们要留意n,ai,bi的范围，都是[1,1000]。这个范围真的不算大，那么我们就可以使用数组定义哈希表。

也就是我们定义ctnA，ctnB的大小均为1001，初始化为0的数组，分别记录a和b中出现不同数字的个数。

在我们后续遍历的时候，先遍历sum（即a，b的和），注意由于a,b的范围，这里sum的范围是[2,2000]。

再在[1,1000]遍历ctn[A],差值遍历ctn[b]，找俩个里的最小值，加在一起，就是能组成sum这个价格的数量了。

好题好题！

~~~
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    int  n;
    cin>>n;
    vector<int> ai(n);
    vector<int> bi(n);
    for(int i = 0;i<n;i++)
    {
        cin>>ai[i];
    }
    for(int i = 0;i<n;i++)
    {
        cin>>bi[i];
    }
   

    const int VMAX = 1000;
    vector<int> cntA(VMAX+1,0),cntB(VMAX+1,0);
    for(int x:ai) cntA[x]++;
    for(int y:bi) cntB[y]++;

    int result = 0;
    for(int sum = 2;sum<=2*VMAX;sum++)
    {
        int pair = 0;
        for(int x = 1;x<min(sum,1001);x++)
        {
            int y = sum-x;
            if(y<1||y>VMAX)continue;
            pair += min(cntA[x],cntB[y]);
        }
        result = max(result,pair);
    }

    cout<<result<<endl;
    return 0;
}
~~~

## 116.小欧的卡牌

[题目链接](https://kamacoder.com/problempage.php?pid=1189)

实在是没什么思路，知道递归回溯的时间大，但实在不知道别的方法了，先拿这个试一试，但不出意料超时了。

~~~
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;

int traversal(int i,int val,int n,vector<vector<int>>& nums)
{
    if(i==n-1&&val%3==0)  return 1;
    if(i==n-1&&val%3!=0)  return 0;
    int a = (val + nums[i+1][0])%MOD; 
    int b = (val + nums[i+1][1])%MOD; 
    return (traversal(i+1,a,n,nums)+traversal(i+1,b,n,nums))%MOD;
}

int main()
{
    int n;
    cin>>n;
    vector<vector<int>> nums(n,vector<int>(2));
    for(int i = 0;i<n;i++)
    {
        cin>>nums[i][0]>>nums[i][1];
    }

    cout<<(traversal(0,nums[0][0],n,nums)+traversal(0,nums[0][1],n,nums))%MOD<<endl;
    return 0;
}
~~~

看了题解，发现这道题居然可以用动规来解决。

最近我也是刚做完代码随想录的动态规划章节，虽然熟悉，不过思维也有些固化到那些题目的解法上了，以为只能定义dp[n][2]，列是正反面俩种。

但没想到dp数组的定义是：dp[i][r] 表示用前 i 张卡牌、每张选一面后，总和模 3 等于 r 的方案数。

这种动规的时间复杂度极低，长见识了。

不过其实我对这道题的初始化还是不太明白，当没有卡牌时，dp[0][0]=1这个。

只能这么理解，没有卡牌的时候，有和为0的一个空方案。而且如果没有dp[0][0]=1初始化，后面计算后的dp也全是0，所以这个初始化是必要的。

~~~
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;
const int MAX_M = 3;

int main()
{
    int n;
    cin>>n;
    vector<vector<int>> nums(n,vector<int>(2));
    for(int i = 0;i<n;i++)
    {
        cin>>nums[i][0]>>nums[i][1];
    }

    vector<vector<int>> dp(n+1,vector<int>(MAX_M,0));
    dp[0][0] = 1;

    for(int i = 1;i<=n;i++)
    {
        for(int j = 0;j<MAX_M;j++)
        {
            for(int k = 0;k<2;k++)
            {
                int sum = (j+nums[i-1][k])%MAX_M;
                dp[i][sum] = (dp[i][sum] + dp[i-1][j])%MOD;
            }
        }
    }
    cout<<dp[n][0];
    return 0;
}
~~~