# 2023年OPPO提前批笔试真题0715

## 111.构造二阶行列式

[题目链接](https://kamacoder.com/problempage.php?pid=1184)

这道题初看没什么思路，想到的只有暴力搜索，四重循环，但没敢尝试。

可以用unordered_map + 二重循环 **边搜索边添加**的方法。

二重循环i，j表示的是俩个相乘的数，不一定是ad，或者是bc。

当我们得到俩数乘积时，我们考虑乘积与x的关系，分别考虑如果这个成绩是ad或者是bc时，map中是否存在另一组数。

如果存在另一组数，那就证明出现了结果。

如果不存在，那我们就将乘积加入到count，注意一个数值在map中只需一组组合即可，因为只要一个结果。

~~~
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;


vector<int> findDeterminant(int x)
{
    vector<int> result(4,0);
    unordered_map<int,pair<int,int>> map;
    for(int i = 1;i<=20;i++)
    {
        for(int j = 1;j<=20;j++)
        {
            int sum = i*j;
            if(map.count(sum-x))
            {
                result[0] = i;
                result[3] = j;
                result[1] = map[sum-x].first;
                result[2] = map[sum-x].second;
                return result;
            }
            if(map.count(sum+x))
            {
                result[1] = i;
                result[2] = j;
                result[0] = map[sum+x].first;
                result[3] = map[sum+x].second;
                return result;
            }

            if(!map.count(sum))
            {
                pair<int,int> my_pair(i,j);
                map[sum] = my_pair;
            }
        }
    }
    return {};
}

int main()
{
    int x;
    cin>>x;
    vector<int> res(4,0);
    res = findDeterminant(x);
    if(res.empty())
    {
        cout<<"-1";
        return 0;
    }
    cout<<res[0]<<" "<<res[1]<<endl;
    cout<<res[2]<<" "<<res[3];
    return 0;
}
~~~

## 112.挑战boss

[题目链接](https://kamacoder.com/problempage.php?pid=1185)

说实话，不知道为啥这种题也能放进笔试题里，可能是出道简单题？

过程就不讲了，看了题目其实就都会了，没有任何难点。

~~~
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int n,a,b;
    cin>>n>>a>>b;
    int hurt = 0;
    int continousNum = 0;
    vector<char> vec(n);
    for(int i = 0;i<n;i++)
    {
        cin>>vec[i];
    }
    for(int i = 0;i<n;i++)
    {
        hurt += (a + b*continousNum);
        if(vec[i]=='o')
        {
            continousNum++;
        }
        else if(vec[i]=='x') continousNum = 0;
    }
    cout<<hurt<<endl;
    return 0;
}
~~~

## 113.国际象棋

[题目链接](https://kamacoder.com/problempage.php?pid=1186)

这题真给孩子干蒙了，以为很简单，但是有超级多细节没有考虑。

首先我先说一下分类，无论怎么走，最少零步，最多三步。

零步： 那就是出发点和终点是同一个点。

一步： 一步马可以走到或者是一步象（终点和起点在一个斜线上）。

两步： 先考虑起点和重点处于同色格上，两步象可以走到；

然后考虑一步马和一步象：这种情况我最开始的想法不对了，我只考虑先走斜线，看看斜线上的点和终点的最小值是否小于3、

但这么考虑有俩个问题：

1.没有考虑时间的问题，如果起点和终点位置很远，这个循环的时间是很大的。

2.只考虑了先象后马的情况，但是先马后象和先象后马是不一样的。
      
所以可以写出马的移动位置（类似star*算法的步骤），判断起点走了一步马是否和终点在一条斜线上（先马后象），或者终点回退一步马是否和起点在一条斜线上（先象后马）。这种循环内只有8次，大大节约了时间。

三步： 如果前三种情况都不满足的话，那就是三步了。因为三步（二步象 + 一步马）一定可以走到异色格的任意位置。

由于我刚开始的思路不太完美，导致部分函数名称等不符合意思以及其实可以更加优化一些代码，但懒得改了 :)

~~~
#include <iostream>
#include <vector>
#include <climits>
using namespace std;



bool getPos(int x1,int y1,int x2,int y2)
{
    static const int kdx[8] = { 1, 2, -1, -2,  1,  2, -1, -2 };
    static const int kdy[8] = { 2, 1,  2,  1, -2, -1, -2, -1 };
    for(int i = 0;i<8;i++)
    {
        if(abs(x1+kdx[i]-x2)==abs(y1+kdy[i]-y2))return true;
        if(abs(kdx[i]+x2-x1)==abs(kdy[i]+y2-y1))return true;
    }
    return false;
}

bool isOneStep(int x1,int y1,int x2,int y2)
{
    if(abs(x2-x1)==abs(y2-y1))return true;
    if((abs(x2-x1)+abs(y2-y1))==3&&abs(x2-x1)!=3&&abs(y2-y1)!=3)return true; 
    return false;
}

bool isTwoStep(int x1,int y1,int x2,int y2)
{
    if((abs(x1+y1)%2)==(abs(x2+y2)%2))return true;
    if(getPos(x1,y1,x2,y2))return true; 
    return false;
}

int jump(int x1,int y1,int x2,int y2)
{
    if(x1==x2&&y1==y2) return 0;
    if(isOneStep(x1,y1,x2,y2))return 1;
    if(isTwoStep(x1,y1,x2,y2))return 2;
    return 3;
}

int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
        cout<<jump(x1,y1,x2,y2)<<endl;
    }
    return 0;
}
~~~
