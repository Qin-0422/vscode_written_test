# 2023年美团秋季笔试真题0812

## 128.小美的排列询问

[题目链接](https://kamacoder.com/problempage.php?pid=1204)

没什么好说的，简单题。

~~~
#include <bits/stdc++.h>
using namespace std;

bool isNear(vector<int>& arr,int x,int y,int n)
{
 if(arr[0]==x)
    {
        if(arr[1]==y) return true;
    }
    if(arr[n-1]==x)
    {
        if(arr[n-2]==y) return true;
    }

    for(int i = 1;i<n-1;i++)
    {
        if(arr[i]==x)
        {
            if(arr[i-1]==y||arr[i+1]==y) return true;
        }
    }
    return false;
}
int main()
{
    int n;
    cin>>n;
    vector<int> arr(n);
    for(int i = 0;i<n;i++)
    {
        cin>>arr[i];
    }
    int x,y;
    cin>>x>>y;
    if(isNear(arr,x,y,n))cout<<"Yes";
    else cout<<"No";
    return 0;
}
~~~

## 129.小美走公路

[题目链接](https://kamacoder.com/problempage.php?pid=1205)

简单题.

~~~
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n,x,y;
    cin>>n;
    vector<long long> arr(n,0);
    long long AllDistance = 0;
    for(int i = 0;i<n;i++)
    {
        cin>>arr[i];
        AllDistance += arr[i];
    }
    cin>>x>>y;
    if(x>y) swap(x,y);
    long long PartDistance = 0;
    for(int i = x-1;i<y-1;i++)
    {
        PartDistance += arr[i];
    }
    PartDistance<AllDistance-PartDistance ? cout<<PartDistance : cout<<AllDistance-PartDistance;
    return 0;
}
~~~





## 130.小美的蛋糕切割

[题目链接](https://kamacoder.com/problempage.php?pid=1206)

一个很经典的前缀和问题.但是我没想起来,觉得行列加起来,双指针考虑.

虽然做出来,但是写的很糟糕,而且不太记得起来前缀和怎么写了.

明天把前缀和解法复习一下.

~~~
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,m;
    cin>>n>>m;
    vector<vector<int>> cake(n,vector<int>(m,0));
    vector<int> colCake(n,0);
    vector<int> rowCake(m,0);

    for(int i = 0;i<n;i++)
    {
        for(int j = 0;j<m;j++)
        {
            cin>>cake[i][j];
            colCake[i] += cake[i][j];
            rowCake[j] += cake[i][j];
        }
    }

    int leftIndex,rightIndex,highIndex,lowIndex;
    leftIndex = 0;
    rightIndex = m-1;
    highIndex = 0;
    lowIndex = n-1;

    int leftSum = rowCake[0], rightSum = rowCake[m-1],highSum = colCake[0],lowSum = colCake[n-1];


    while(leftIndex<rightIndex)
    {
        if(leftSum<=rightSum)
        {
            leftIndex++;
            if(leftIndex<rightIndex)leftSum += rowCake[leftIndex];
        }
        else if(leftSum>rightSum)
        {
            rightIndex--;
            if(leftIndex<rightIndex) rightSum += rowCake[rightIndex];
        }
    }
    
    while(highIndex<lowIndex)
    {
        if(highSum<=lowSum)
        {
            highIndex++;
            if(highIndex<lowIndex)highSum += colCake[highIndex];
        }
        else if(highSum>lowSum)
        {
            lowIndex--;
            if(highIndex<lowIndex) lowSum += colCake[lowIndex];
        }
    } 


    if(n==1) cout<<abs(leftSum-rightSum);
    else if(m==1) cout<<abs(highSum-lowSum);
    else if(abs(leftSum-rightSum)>abs(highSum-lowSum)) cout<<abs(highSum-lowSum);
    else cout<<abs(leftSum-rightSum);
    return 0;
}
~~~


## 131.小美的字符串变换

[题目链接](https://kamacoder.com/problempage.php?pid=1207)

唉，连通块，很眼熟的一道题，当年要是做出来，是不是就铜牌了？ 嘿嘿。

感觉最近做题总是缺了些下手的勇气，觉得肯定做不出来，下次还是要自己尝试尝试。

这道题其实就是一个深搜的变形，遍历a行b列 n = a * b，遇见能整除的再进行深搜。

外层while循环是 a < b ，内层每整除一次，就修改b值，这样我们就不会遇到重复的 a和b（即前a=后b，前b＝后a的情况）。 

~~~
#include <bits/stdc++.h>
using namespace std;
int dir[4][2] ={1,0,-1,0,0,1,0,-1};
void dfs(const vector<vector<char>>& words,vector<vector<bool>>& visited,int x,int y)
{
    if(visited[x][y])return;
    visited[x][y] = true;
    for(int i = 0;i<4;i++)
    {
        int cur_x = x + dir[i][0];
        int cur_y = y + dir[i][1];
        if(cur_x<0||cur_x>=words.size()||cur_y<0||cur_y>=words[0].size())continue;
        if(!visited[cur_x][cur_y]&&words[x][y]==words[cur_x][cur_y])
        dfs(words,visited,cur_x,cur_y);
    }
}
int main()
{
    int n;
    cin>>n;
    string word;
    for(int i = 0;i<n;i++)
    {
        char a;
        cin>>a;
        word += a;
    }
    int a = 1;
    int b = n;
    int result = n;
    while (a<=b)
    {
        if(n%a==0)
        {
            //这步很细节
            b = n/a;

            vector<vector<char>> words(a,vector<char>(b));
            int k = 0;
            for(int i = 0;i<a;i++)
            {
                for(int j = 0;j<b;j++)
                {
                    words[i][j] = word[k];
                    k++;
                }
            }

            int count = 0;
            vector<vector<bool>> visited(a,vector<bool>(b,false));
             for(int i = 0;i<a;i++)
            {
                for(int j = 0;j<b;j++)
                {
                   if(!visited[i][j])
                   {
                        count++;
                        dfs(words,visited,i,j);
                   }
                }
            }
            result = min(result,count);
        }
        a++;
    }
    cout<<result<<endl;
    return 0;
}
~~~

## 132.小美的树上染色

[题目链接](https://kamacoder.com/problempage.php?pid=1208)

感觉这题还真不错，最初我有一个想法的雏形，就是利用深搜或者广搜去挨着去找相邻节点是否数值乘积是完全平方数，但意识到一个很严重的问题，就是我没办法找到最多的染红节点数。

看了眼评论区，发现了一个不错的思路：

其实还是深搜，只不过我们构建的不是图，而是树。

如果用树的话就会有一个不错的性质：

- 后序匹配相当于“叶子优先”的策略：子树先尽量自我匹配，若子节点 v 最终仍白色，说明在它的子树中无法找到任何与它相邻的可匹配边，此时唯一能让 v 被染红的机会就是与父节点 u 匹配（若合法且 u 也未匹配）。
- 在树上，“叶子优先匹配”是最大匹配的一个线性时间算法变体：每个节点最多参与一次匹配，父子间只在子节点无法在其子树中匹配时才匹配，这避免了中间边的“抢占”从而减少可匹配对数。

这样就能解决我最初的问题了，感觉这也是很多题用递归的原因。

然后我觉得这个dfs函数写的也有很多细节需要注意。

~~~
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int n;
vector<ll> arr(100001);
vector<bool> red(100001,false);
vector<vector<int>> tree(100001);

bool isAiming(ll n)
{
    ll root = sqrt(n);
    if(root*root == n) return true;
    else return false;
}

int dfs(int u,int parent)
{
    int count = 0;
    for(int v:tree[u])
    {
        if(v==parent)continue;
        count += dfs(v,u);
        if(!red[u]&&!red[v]&&isAiming(arr[u]*arr[v]))
        {
            red[u] = true;
            red[v] = true;
            count += 2;
        }
    }
    return count;
}

int main()
{
    cin>>n;
    for(int i = 1;i<=n;i++)
    {
        cin>>arr[i];
    }

    int u,v;
    for(int i = 1;i<n;i++)
    {
        cin>>u>>v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }

    int res = dfs(1,-1);
    cout<<res<<endl;
    return 0;
}
~~~
